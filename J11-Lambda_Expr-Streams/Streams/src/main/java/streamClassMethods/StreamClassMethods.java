package main.java.streamClassMethods;

import java.util.stream.Stream;

public class StreamClassMethods {

    public static void main(String args[]) {

        /*  Stream.of()
         *   -> creates a new Stream with specified items.
         */
        Stream<String> igNumberStream = Stream.of("I26", "I17", "I29", "i5", "i34", "G53", "G49", "G60", "G50", "g64");
        Stream<String> inNumberStream = Stream.of("I26", "I17", "I29", "N40", "N36");
        Stream<String> ioNumberStream = Stream.of("I26", "I17", "I29", "O71");


        /* Stream.concat()
         *   -> concatenates the items of two Stream objects. Creates a new Stream.
         *   -> Can't use in intermediate operations, since "concat()" is a 'static' method.
         */
        Stream<String> concatNumStream = Stream.concat(igNumberStream, inNumberStream);
        concatNumStream.forEach(System.out::println);


        /*  <stream instance>.count()
         *   -> counts all items in a list. Returns a 'long'. Terminal operation.
         */
        countAllItems();

        // System.out.println("\nCount of all items :: " + concatNumStream.count());
        // causes a runtime error. Stream has already been operated upon or closed, above in "concatNumStream.forEach(System.out::println);"

        // Stream<String> newConcatStream1 = Stream.concat(igNumberStream, inNumberStream);
        // creating a new Stream reference variable doesn't work. Stream generated by "concat()" method is already used.


        /* <stream instance>.distinct()
         *   -> filter distinct elements of a Stream, using 'equals()' method logic.
         */
        printDistinctItems();


        /* <stream instance>.peek()
         *   -> Accepts a "Consumer" object. Evaluates the Consumer passing each item.
         *   -> Intermediate operation. Returns a Stream of same type.
         *   -> Not a terminal operation like 'forEach()'.
         */
        peekItems();


        /*  Stream's lazy evaluation test  */
        Stream.of("AA", "ABA", "ACB", "BC", "ABC", "BBB", "CCA", "BA")
                .filter((str) -> {
                    System.out.println("**" + str);
                    return (str.length() == 3);
                })
                .forEach(System.out::println);
    }

    /*  peek()  */
    public static void peekItems() {
        Stream<String> igNumberStream = Stream.of("I26", "I17", "I29", "i5", "i34", "G53", "G49", "G60", "G50", "g64");
        Stream<String> inNumberStream = Stream.of("I26", "I17", "I29", "N40", "N36");

        Stream<String> concatNumStream = Stream.concat(igNumberStream, inNumberStream);

        System.out.println("\nPeek items :: ");
        System.out.println("\nDistinct item count ::" +
                concatNumStream
                        .distinct()
                        .peek(System.out::println)
                        .count());
    }

    /*  distinct()  */
    public static void printDistinctItems() {
        Stream<String> igNumberStream = Stream.of("I26", "I17", "I29", "i5", "i34", "G53", "G49", "G60", "G50", "g64");
        Stream<String> inNumberStream = Stream.of("I26", "I17", "I29", "N40", "N36");

        Stream<String> concatNumStream = Stream.concat(igNumberStream, inNumberStream);

        System.out.println("\nDistinct items :: ");
        concatNumStream
                .distinct()
                .forEach(System.out::println);
    }

    /*  count()  */
    public static void countAllItems() {
        Stream<String> igNumberStream = Stream.of("I26", "I17", "I29", "i5", "i34", "G53", "G49", "G60", "G50", "g64");
        Stream<String> inNumberStream = Stream.of("I26", "I17", "I29", "N40", "N36");

        Stream<String> concatNumStream = Stream.concat(igNumberStream, inNumberStream);

        System.out.println("\nCount of all items :: " +
                concatNumStream.count());
    }

}
